# core.Config.ts

> 50 개 이상의 설정을 관리하는 중앙 집중식 제어 클래스

> cli.loadConfig 함수는 그저 아래에서 소개할 거대한 Class 를 로그하는 단순한 함수 입니다.

## 핵심 서비스 관리

```typescript
export class Config {
    private toolRegistry!: ToolRegistry;
    private promptRegistry!: PromptRegistry;
    private readonly sessionId: string;
    private contentGeneratorConfig!: ContentGeneratorConfig;
    private readonly embeddingModel: string;
    private readonly sandbox: SandboxConfig | undefined;
    private readonly targetDir: string;
    private workspaceContext: WorkspaceContext;
    ...
}
```

## 생성자

```typescript
constructor(params: ConfigParameters) {
    this.sessionId = params.sessionId;
    this.embeddingModel =
      params.embeddingModel ?? DEFAULT_GEMINI_EMBEDDING_MODEL;
    this.sandbox = params.sandbox;
    this.targetDir = path.resolve(params.targetDir);
    this.workspaceContext = new WorkspaceContext(
        this.targetDir,
        params.includeDirectories ?? [],
    );
}
```

## `initialize()` - 서비스 초기화

```typescript
async initialize(): Promise<void> {
    // 1. 파일 탐색 서비스 초기화
    this.getFileService();

    // 2. Git 서비스 초기화 (체크포인팅 활성화)
    if (this.getCheckpointingEnabled()) {
        await this.getGitService();
    }

    // 3. 프롬프트 레지스트리 생성
    this.promptRegistry = new PromptRegistry();

    // 4. 도구 레지스트리 생성 및 도구 등록
    this.toolRegistry = await this.createToolRegistry();
}
```

## `refreshAuth()` - 인증 방식 변경

```typescript
async refreshAuth(authMethod: AuthType) {
    // Save the current conversation history before creating a new client
    let existingHistory: Content[] = [];
    if (this.geminiClient && this.geminiClient.isInitialized()) {
        existingHistory = this.geminiClient.getHistory();
    }

    // Create new content generator config
    const newContentGeneratorConfig = createContentGeneratorConfig(
        this,
        authMethod,
    );

    // Create and initialize new client in local variable first
    const newGeminiClient = new GeminiClient(this);
    await newGeminiClient.initialize(newContentGeneratorConfig);

    // Only assign to instance properties after successful initialization
    this.contentGeneratorConfig = newContentGeneratorConfig;
    this.geminiClient = newGeminiClient;

    // Restore the conversation history to the new client
    if (existingHistory.length > 0) {
        this.geminiClient.setHistory(existingHistory);
    }

    // Reset the session flag since we're explicitly changing auth and using default model
    this.inFallbackMode = false;
}
```

* 먼저 로컬 변수에서 초기화
* 성공 후에만 인스턴스 변수에 할당
* 대화 히스토리 손실 방지

## 도구 시스템 관리

```typescript
async createToolRegistry(): Promise<ToolRegistry> {
    const registry = new ToolRegistry(this);

    // helper to create & register core tools that are enabled
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const registerCoreTool = (ToolClass: any, ...args: unknown[]) => {
        const className = ToolClass.name;
        const toolName = ToolClass.Name || className;
        const coreTools = this.getCoreTools();
        const excludeTools = this.getExcludeTools();

        let isEnabled = false;
        if (coreTools === undefined) {
            isEnabled = true;
        } else {
            isEnabled = coreTools.some(
            (tool) =>
                tool === className ||
                tool === toolName ||
                tool.startsWith(`${className}(`) ||
                tool.startsWith(`${toolName}(`),
            );
        }

        if (
            excludeTools?.includes(className) ||
            excludeTools?.includes(toolName)
        ) {
            isEnabled = false;
        }

      if (isEnabled) {
            registry.registerTool(new ToolClass(...args));
        }
    };

    registerCoreTool(LSTool, this);
    registerCoreTool(ReadFileTool, this);
    registerCoreTool(GrepTool, this);
    registerCoreTool(GlobTool, this);
    registerCoreTool(EditTool, this);
    registerCoreTool(WriteFileTool, this);
    registerCoreTool(WebFetchTool, this);
    registerCoreTool(ReadManyFilesTool, this);
    registerCoreTool(ShellTool, this);
    registerCoreTool(MemoryTool);
    registerCoreTool(WebSearchTool, this);

    await registry.discoverAllTools();
    return registry;
}
```

## 설계 패턴

* 필요할 때까지 서비스 생성하지 않는 **Lazy Initialization** 방식 사용

```typescript
async getGitService(): Promise<GitService> {
    if (!this.gitService) {
        this.gitService = new GitService(this.targetDir);
        await this.gitService.initialize();
    }
    return this.gitService;
}

getFileService(): FileDiscoveryService {
    if (!this.fileDiscoveryService) {
        this.fileDiscoveryService = new FileDiscoveryService(this.targetDir);
    }
    return this.fileDiscoveryService;
}
```


* 상태 머신 패턴

```typescript
// 모델 폴백 상태 관리
private inFallbackMode = false;
private quotaErrorOccurred: boolean = false;

setFallbackMode(active: boolean): void {
    this.inFallbackMode = active;
}
```

* 팩토리 패턴
```typescript
// 조건부 도구 생성
const registerCoreTool = (ToolClass: any, ...args: unknown[]) => {
    // 설정에 따라 도구 생성 여부 결정
    if (isEnabled) {
        registry.registerTool(new ToolClass(...args));
    }
};
```

* 의존성 주입

```typescript
// Config 자체를 의존성으로 주입
new LSTool(this);
new ReadFileTool(this);
new GeminiClient(this);
```