# `main` 함수 진입점

파일: `packages/cli/src/gemini.tsx`

```typescript
setupUnhandledRejectionHandler();
const workspaceRoot = process.cwd();
const settings = loadSettings(workspaceRoot);
```

* **setupUnhandledRejectionHandler** : 처리되지 않은 Promise 거부를 위한 전역 핸들러 설정
  * `process.on('unhandledRejection', (reason, _promise) => { ... })` : Node.js 의 **process 객체**에 `unhandledRejection` 이벤트 리스너를 추가
  * `let unhandledRejectionOccurred = false;` : 중복 처리 방지, 연쇄적인 에러로 인한 콘솔 중복 실행 방지
  * `appEvents.emit` : 이벤트 발생
* `const workspaceRoot = process.cwd();` : 현재 작업 디렉토리 경로를 가져옴
* `const settings = loadSettings(workspaceRoot);` : 현재 작업 디렉토리에서 설정을 로드

Promise 거부가 처리되지 않은 경우 **setupUnhandledRejectionHandler** 함수가 호출되어, 에러 메시지를 출력하고 로깅

첫번째 실행시 디버그 모드를 활성화해 상세한 로그 출력


## unhandledRejection

> 쉽게 말해서 **Promise** 에 `catch` 가 없을 때 발생하는 에러 파이썬 앱 개발을 할때도 비슷한 개념이 존재하고 하는게 좋다

```typescript
async function example() {
  try {
    await somePromise();
  } catch (error) {
    // 에러 처리됨 - unhandledRejection 발생 안함
  }
}

somePromise()
  .then(result => { ... })
  .catch(error => {
    // 에러 처리됨 - unhandledRejection 발생 안함
  });

// 이런 경우들이 unhandledRejection을 발생시킴
somePromise(); // .catch() 없음
Promise.reject('error'); // 처리 안함

async function badExample() {
  await somePromise(); // try-catch 없음
}
```


## loadSettings

현재 작업 디렉토리 경로를 받아서 `LoadedSettings` 객체를 반환하는 함수

`settings.ts` 파일에서 정의되어 있으며, 이 함수는 여러 설정 파일을 로드하고 병합하여 최종 설정을 반환

```typescript
loadEnvironment();
let systemSettings: Settings = {};
let userSettings: Settings = {};
let workspaceSettings: Settings = {};
const settingsErrors: SettingsError[] = [];
const systemSettingsPath = getSystemSettingsPath();
```

* loadEnvironment : **dotenv** 패키지를 사용하여 `.env` 파일에서 환경 변수 로드
* 여러 세팅값 들을 초기화
  * `systemSettings` : 시스템 설정
  * `userSettings` : 사용자 설정
  * `workspaceSettings` : 작업 공간 설정
  * `settingsErrors` : 설정 에러 목록
* `getSystemSettingsPath` : OS별로 다른 시스템 설정 경로 가져오기


### loadEnvironment

```typescript
export function loadEnvironment(): void {
  const envFilePath = findEnvFile(process.cwd());

  if (process.env.CLOUD_SHELL === 'true') {
    setUpCloudShellEnvironment(envFilePath);
  }

  if (envFilePath) {
    dotenv.config({ path: envFilePath, quiet: true });
  }
}
```

### getSystemSettingsPath

```typescript
export function getSystemSettingsPath(): string {
  if (process.env.GEMINI_CLI_SYSTEM_SETTINGS_PATH) {
    return process.env.GEMINI_CLI_SYSTEM_SETTINGS_PATH;
  }
  if (platform() === 'darwin') {
    return '/Library/Application Support/GeminiCli/settings.json';
  } else if (platform() === 'win32') {
    return 'C:\\ProgramData\\gemini-cli\\settings.json';
  } else {
    return '/etc/gemini-cli/settings.json';
  }
}
```

여기선 user 설정을 로드하는것 까지만 정리

```typescript
import path from 'path';
import { homedir } from 'os';

export const SETTINGS_DIRECTORY_NAME = '.gemini';
export const USER_SETTINGS_DIR = path.join(homedir(), SETTINGS_DIRECTORY_NAME);
export const USER_SETTINGS_PATH = path.join(USER_SETTINGS_DIR, 'settings.json');
```

`settings.ts` 최상단 세팅값, 이것 이외에도 여러 타입들과 위 함수들(loadSettings, getSystemSettingsPath 등)도 정의되어 있음

```typescript
// Load user settings
try {
  if (fs.existsSync(USER_SETTINGS_PATH)) {
    const userContent = fs.readFileSync(USER_SETTINGS_PATH, 'utf-8');
    const parsedUserSettings = JSON.parse(
      stripJsonComments(userContent),
    ) as Settings;
    userSettings = resolveEnvVarsInObject(parsedUserSettings);
    // Support legacy theme names
    if (userSettings.theme && userSettings.theme === 'VS') {
      userSettings.theme = DefaultLight.name;
    } else if (userSettings.theme && userSettings.theme === 'VS2015') {
      userSettings.theme = DefaultDark.name;
    }
  }
} catch (error: unknown) {
  settingsErrors.push({
    message: getErrorMessage(error),
    path: USER_SETTINGS_PATH,
  });
}
```

1. `./gemini/settings.json` 파일을 utf-8 로 읽기
2. `stripJsonComments` 함수를 사용하여 주석 제거
3. JSON 파싱 후 `Settings` 타입으로 변환
4. `resolveEnvVarsInObject` 함수를 사용하여 환경 변수 치환
  * 설정값 내의 `$VAR_NAME` 또는 `${VAR_NAME}` 형태의 환경변수를 실제 값으로 치환
5. 에러 발생시 `settingsErrors` 배열에 에러 메시지와 경로 추가

### resolveEnvVarsInObject

```typescript
function resolveEnvVarsInString(value: string): string {
  const envVarRegex = /\$(?:(\w+)|{([^}]+)})/g; // Find $VAR_NAME or ${VAR_NAME}
  return value.replace(envVarRegex, (match, varName1, varName2) => {
    const varName = varName1 || varName2;
    if (process && process.env && typeof process.env[varName] === 'string') {
      return process.env[varName]!;
    }
    return match;
  });
}

function resolveEnvVarsInObject<T>(obj: T): T {
  if (
    obj === null ||
    obj === undefined ||
    typeof obj === 'boolean' ||
    typeof obj === 'number'
  ) {
    return obj;
  }

  if (typeof obj === 'string') {
    return resolveEnvVarsInString(obj) as unknown as T;
  }

  if (Array.isArray(obj)) {
    return obj.map((item) => resolveEnvVarsInObject(item)) as unknown as T;
  }

  if (typeof obj === 'object') {
    const newObj = { ...obj } as T;
    for (const key in newObj) {
      if (Object.prototype.hasOwnProperty.call(newObj, key)) {
        newObj[key] = resolveEnvVarsInObject(newObj[key]);
      }
    }
    return newObj;
  }

  return obj;
}
```

## await cleanupCheckpoints();

```typescript
export async function cleanupCheckpoints() {
  const tempDir = getProjectTempDir(process.cwd());
  const checkpointsDir = join(tempDir, 'checkpoints');
  try {
    await fs.rm(checkpointsDir, { recursive: true, force: true });
  } catch {
    // Ignore errors if the directory doesn't exist or fails to delete.
  }
}
```
* tempDir = "C:\\Users\\username\\.gemini\\tmp\\project-hash"
* checkpointsDir = "C:\\Users\\username\\.gemini\\tmp\\project-hash\\checkpoints"

체크포인트 폴더가 존재한다면 뿌리째 삭제

### getProjectTempDir

```typescript
export const GEMINI_DIR = '.gemini';
export const GOOGLE_ACCOUNTS_FILENAME = 'google_accounts.json';
const TMP_DIR_NAME = 'tmp';
const COMMANDS_DIR_NAME = 'commands';

export function getProjectHash(projectRoot: string): string {
  return crypto.createHash('sha256').update(projectRoot).digest('hex');
}

export function getProjectTempDir(projectRoot: string): string {
  const hash = getProjectHash(projectRoot);
  return path.join(os.homedir(), GEMINI_DIR, TMP_DIR_NAME, hash);
}
```

이후 settings 의 error 가 존재 한다면 에러 메시지를 출력하고 종료

```typescript
if (settings.errors.length > 0) {
  ...
  process.exit(1);
}
```

그 다음 `parseArguments` 함수를 호출하여 명령행 인수를 파싱하고, `loadExtensions` 함수를 사용하여 확장 기능을 로드

```typescript
const argv = await parseArguments();
const extensions = loadExtensions(workspaceRoot);
const config = await loadCliConfig(
  settings.merged,
  extensions,
  sessionId,
  argv,
);
```

* args : https://github.com/google-gemini/gemini-cli/blob/main/docs/cli/configuration.md#command-line-arguments
* extensions : https://github.com/google-gemini/gemini-cli/blob/main/docs/extension.md

## parseArguments


## loadExtensions

**type**

```typescript
export interface Extension {
  path: string;
  config: ExtensionConfig;
  contextFiles: string[];
}
```

**핵심 역할**

> 확장 프로그램을 계층적으로 로드하고 중복을 제거





## localCliConfig

먼저 `Config` 는 `@google/gemini-cli-core` 패키지에서 가져온것, `sessionId` 또한 마찬가지

```typescript
import {
  Config,
  ...
} from '@google/gemini-cli-core';
```


> Config 에 대한 간략한 설명
>
> Config 클래스는 Gemini CLI의 중앙 설정 저장소이자 실행 환경의 청사진입니다. 모든 구성 요소가 동일한 설정을 참조하도록 하는 단일 진실 공급원(Single Source of Truth) 역할을 합니다. (세션 고유 식별자, 작업 디렉토리, 사용할 AI 모델 등을 포함)


```typescript
const debugMode =
  argv.debug ||
  [process.env.DEBUG, process.env.DEBUG_MODE].some(
    (v) => v === 'true' || v === '1',
  ) ||
  false;
const memoryImportFormat = settings.memoryImportFormat || 'tree';
const ideMode =
  (argv.ideMode ?? settings.ideMode ?? false) &&
  process.env.TERM_PROGRAM === 'vscode';

const ideModeFeature =
  (argv.ideModeFeature ?? settings.ideModeFeature ?? false) &&
  !process.env.SANDBOX;

const ideClient = IdeClient.getInstance(ideMode && ideModeFeature);

const allExtensions = annotateActiveExtensions(
  extensions,
  argv.extensions || [],
);

const activeExtensions = extensions.filter(
  (_, i) => allExtensions[i].isActive,
);
```

* debugMode : 디버그 모드 활성화 여부, CLI 인수(`--debug`) 또는 환경변수가 `true` 또는 `1`인 경우 활성화, 기본값은 `false`
* memoryImportFormat : 메모리 가져오기 형식, 기본값은 `tree`
* ideMode : VSCode에서 실행 중인지 확인 하는 여부
* ideModeFeature : IDE 모드 기능 활성화 여부, CLI 인수 또는 설정에서 가져오며, 샌드박스 환경에서는 비활성화
* ideClient : IDE 클라이언트 인스턴스, IDE 모드가 활성화된 경우에만 생성
* allExtensions : 활성화된 확장 기능 목록
* activeExtensions : 실제로 활성화된 확장 기능만 필터링

### process.env

> `process.env` 는 Node.js에서 현재 프로세스의 환경 변수를 나타내는 객체

vscode 에서 실행 중인지 확인하는 방법은 `process.env.TERM_PROGRAM` 이 `vscode` 인지 확인하는 것

### IdeClient

> Gemini CLI와 IDS(VScode) 간의 브릿지 역할을 하는 클래스 로서 CLI가 터미널에서 실행되면서 IDE와 실시간으로 소통할 수 있게 해주는 통신 관리자

### annotateActiveExtensions

**type**

```typescript
export interface GeminiCLIExtension {
  name: string;
  version: string;
  isActive: boolean;
  path: string;
}
```



***

# 전체 플로우 다이어그램

```
main() 시작
    ↓
┌─────────────────────────┐
│ 1. 초기 설정            │
│ - 작업 디렉토리 확인     │
│ - 설정 파일 로드        │
│ - 체크포인트 정리       │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 2. 설정 검증 및 파싱     │
│ - 명령행 인수 파싱      │
│ - 확장 기능 로드        │
│ - Config 객체 생성      │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 3. 환경 설정            │
│ - 인증 방식 설정        │
│ - 테마 로드            │
│ - 디버그 모드 설정      │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 4. 메모리/샌드박스 처리  │
│ - 메모리 요구사항 확인   │
│ - 샌드박스 환경 확인    │
│ - 필요시 프로세스 재시작 │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 5. UI 모드 결정         │
│ - TTY 환경 확인         │
│ - 입력 소스 결정        │
│ - 대화형/비대화형 분기   │
└─────────────────────────┘
    ↓
┌─────────┐    ┌──────────┐
│대화형 모드│    │비대화형   │
│React UI │    │stdin 처리 │
│렌더링    │    │직접 실행  │
└─────────┘    └──────────┘
```
