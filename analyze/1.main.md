# `main` 함수 진입점

파일: `packages/cli/src/gemini.tsx`

```typescript
export async function main() {
  setupUnhandledRejectionHandler();
  const workspaceRoot = process.cwd();
  const settings = loadSettings(workspaceRoot);
  ...
}
```

* `setupUnhandledRejectionHandler()` : 처리되지 않은 Promise 거부를 위한 전역 핸들러 설정
* `const workspaceRoot = process.cwd();` : 현재 작업 디렉토리 경로를 가져옴
* `const settings = loadSettings(workspaceRoot);` : 현재 작업 디렉토리에서 설정을 로드

## setupUnhandledRejectionHandler()

> 쉽게 말해서 **Promise** 에 `catch` 가 없을 때 발생하는 에러 파이썬 앱 개발을 할때도 비슷한 개념이 존재하고 하는게 좋다

* `process.on('unhandledRejection', (reason, _promise) => { ... })` : Node.js 의 **process 객체**에 `unhandledRejection` 이벤트 리스너를 추가
* `let unhandledRejectionOccurred = false;` : 중복 처리 방지, 연쇄적인 에러로 인한 콘솔 중복 실행 방지
* `appEvents.emit` : 이벤트 발생


**Example**

```typescript
async function example() {
  try {
    await somePromise();
  } catch (error) {
    // 에러 처리됨 - unhandledRejection 발생 안함
  }
}

somePromise()
  .then(result => { ... })
  .catch(error => {
    // 에러 처리됨 - unhandledRejection 발생 안함
  });

// 이런 경우들이 unhandledRejection을 발생시킴
somePromise(); // .catch() 없음
Promise.reject('error'); // 처리 안함

async function badExample() {
  await somePromise(); // try-catch 없음
}
```

## loadSettings

3계층으로 이루어진 설정을 로드하고 병합하는 역할

> 설정 계층 우선순위
>
> System Settings < User Settings < Workspace Settings

**시스템 설정 파일 경로(OS 별로 다름)**
* macOS : `/Library/Application Support/GeminiCli/settings.json`
* Windows : `C:\ProgramData\gemini-cli\settings.json`
* Linux : `/etc/gemini-cli/settings.json`

**유저 설정 파일 경로**
* 공통 : `./.gemini/settings.json`


# await cleanupCheckpoints();

```typescript
export async function cleanupCheckpoints() {
  const tempDir = getProjectTempDir(process.cwd());
  const checkpointsDir = join(tempDir, 'checkpoints');
  try {
    await fs.rm(checkpointsDir, { recursive: true, force: true });
  } catch {
    // Ignore errors if the directory doesn't exist or fails to delete.
  }
}
```
* tempDir = "C:\\Users\\username\\.gemini\\tmp\\project-hash"
* checkpointsDir = "C:\\Users\\username\\.gemini\\tmp\\project-hash\\checkpoints"

체크포인트 폴더가 존재한다면 뿌리째 삭제

## getProjectTempDir

```typescript
export const GEMINI_DIR = '.gemini';
export const GOOGLE_ACCOUNTS_FILENAME = 'google_accounts.json';
const TMP_DIR_NAME = 'tmp';
const COMMANDS_DIR_NAME = 'commands';

export function getProjectHash(projectRoot: string): string {
  return crypto.createHash('sha256').update(projectRoot).digest('hex');
}

export function getProjectTempDir(projectRoot: string): string {
  const hash = getProjectHash(projectRoot);
  return path.join(os.homedir(), GEMINI_DIR, TMP_DIR_NAME, hash);
}
```

# settings.errors 가 존재하는지 확인

이후 settings 의 error 가 존재 한다면 에러 메시지를 출력하고 종료

```typescript
if (settings.errors.length > 0) {
  ...
  process.exit(1);
}
```


# 인수 파싱 및 확장 기능 로드

`parseArguments` 함수를 호출하여 명령행 인수를 파싱하고, `loadExtensions` 함수를 사용하여 확장 기능을 로드

```typescript
const argv = await parseArguments();
const extensions = loadExtensions(workspaceRoot);
const config = await loadCliConfig(
  settings.merged,
  extensions,
  sessionId,
  argv,
);
```

* args : https://github.com/google-gemini/gemini-cli/blob/main/docs/cli/configuration.md#command-line-arguments
* extensions : https://github.com/google-gemini/gemini-cli/blob/main/docs/extension.md

## parseArguments

**type** : `CliArgs`

```typescript
export interface CliArgs {
  model: string | undefined;
  sandbox: boolean | string | undefined;
  sandboxImage: string | undefined;
  debug: boolean | undefined;
  ...
}
```

TODO: 디버깅 결과 포함하기

## loadExtensions

**type** : `Extension[]`

```typescript
export interface Extension {
  path: string;
  config: ExtensionConfig;
  contextFiles: string[];
}
```

TODO: 디버깅 결과 포함하기

> 확장 프로그램을 계층적으로 로드하고 중복을 제거


## localCliConfig

먼저 `Config` 는 `@google/gemini-cli-core` 패키지에서 가져온것, `sessionId` 또한 마찬가지

```typescript
import {
  Config,
  ...
} from '@google/gemini-cli-core';
```


> Config 에 대한 간략한 설명
>
> Config 클래스는 Gemini CLI의 중앙 설정 저장소이자 실행 환경의 청사진입니다. 모든 구성 요소가 동일한 설정을 참조하도록 하는 단일 진실 공급원(Single Source of Truth) 역할을 합니다. (세션 고유 식별자, 작업 디렉토리, 사용할 AI 모델 등을 포함)



***

# 전체 플로우 다이어그램

```
main() 시작
    ↓
┌─────────────────────────┐
│ 1. 초기 설정            │
│ - 작업 디렉토리 확인     │
│ - 설정 파일 로드        │
│ - 체크포인트 정리       │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 2. 설정 검증 및 파싱     │
│ - 명령행 인수 파싱      │
│ - 확장 기능 로드        │
│ - Config 객체 생성      │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 3. 환경 설정            │
│ - 인증 방식 설정        │
│ - 테마 로드            │
│ - 디버그 모드 설정      │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 4. 메모리/샌드박스 처리  │
│ - 메모리 요구사항 확인   │
│ - 샌드박스 환경 확인    │
│ - 필요시 프로세스 재시작 │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 5. UI 모드 결정         │
│ - TTY 환경 확인         │
│ - 입력 소스 결정        │
│ - 대화형/비대화형 분기   │
└─────────────────────────┘
    ↓
┌─────────┐    ┌──────────┐
│대화형 모드│    │비대화형   │
│React UI │    │stdin 처리 │
│렌더링    │    │직접 실행  │
└─────────┘    └──────────┘
```
