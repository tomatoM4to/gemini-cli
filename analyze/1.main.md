# `main` 함수 진입점

파일: `packages/cli/src/gemini.tsx`

```typescript
export function setupUnhandledRejectionHandler() {
  let unhandledRejectionOccurred = false;
  process.on('unhandledRejection', (reason, _promise) => {
    const errorMessage = `=========================================
This is an unexpected error. Please file a bug report using the /bug tool.
CRITICAL: Unhandled Promise Rejection!
=========================================
Reason: ${reason}${
      reason instanceof Error && reason.stack
        ? `
Stack trace:
${reason.stack}`
        : ''
    }`;
    appEvents.emit(AppEvent.LogError, errorMessage);
    if (!unhandledRejectionOccurred) {
      unhandledRejectionOccurred = true;
      appEvents.emit(AppEvent.OpenDebugConsole);
    }
  });
}

setupUnhandledRejectionHandler();
const workspaceRoot = process.cwd();
const settings = loadSettings(workspaceRoot);
```

* **setupUnhandledRejectionHandler** : 처리되지 않은 Promise 거부를 위한 전역 핸들러 설정
  * `process.on('unhandledRejection', (reason, _promise) => { ... })` : Node.js 의 **process 객체**에 `unhandledRejection` 이벤트 리스너를 추가
  * `let unhandledRejectionOccurred = false;` : 중복 처리 방지, 연쇄적인 에러로 인한 콘솔 중복 실행 방지
  * `appEvents.emit` : 이벤트 발생
* `const workspaceRoot = process.cwd();` : 현재 작업 디렉토리 경로를 가져옴
* `const settings = loadSettings(workspaceRoot);` : 현재 작업 디렉토리에서 설정을 로드

Promise 거부가 처리되지 않은 경우 **setupUnhandledRejectionHandler** 함수가 호출되어, 에러 메시지를 출력하고 로깅

첫번째 실행시 디버그 모드를 활성화해 상세한 로그 출력


## unhandledRejection

> 쉽게 말해서 **Promise** 에 `catch` 가 없을 때 발생하는 에러 파이썬 앱 개발을 할때도 비슷한 개념이 존재하고 하는게 좋다

```typescript
async function example() {
  try {
    await somePromise();
  } catch (error) {
    // 에러 처리됨 - unhandledRejection 발생 안함
  }
}

somePromise()
  .then(result => { ... })
  .catch(error => {
    // 에러 처리됨 - unhandledRejection 발생 안함
  });

// 이런 경우들이 unhandledRejection을 발생시킴
somePromise(); // .catch() 없음
Promise.reject('error'); // 처리 안함

async function badExample() {
  await somePromise(); // try-catch 없음
}
```

## loadSettings

3계층으로 이루어진 설정을 로드하고 병합하는 역할

> 설정 계층 우선순위
>
> System Settings < User Settings < Workspace Settings

실제 파일 경로(OS 별로 다름)
* macOS : `/Library/Application Support/GeminiCli/settings.json`
* Windows : `C:\ProgramData\gemini-cli\settings.json`
* Linux : `/etc/gemini-cli/settings.json`


# await cleanupCheckpoints();

```typescript
export async function cleanupCheckpoints() {
  const tempDir = getProjectTempDir(process.cwd());
  const checkpointsDir = join(tempDir, 'checkpoints');
  try {
    await fs.rm(checkpointsDir, { recursive: true, force: true });
  } catch {
    // Ignore errors if the directory doesn't exist or fails to delete.
  }
}
```
* tempDir = "C:\\Users\\username\\.gemini\\tmp\\project-hash"
* checkpointsDir = "C:\\Users\\username\\.gemini\\tmp\\project-hash\\checkpoints"

체크포인트 폴더가 존재한다면 뿌리째 삭제

## getProjectTempDir

```typescript
export const GEMINI_DIR = '.gemini';
export const GOOGLE_ACCOUNTS_FILENAME = 'google_accounts.json';
const TMP_DIR_NAME = 'tmp';
const COMMANDS_DIR_NAME = 'commands';

export function getProjectHash(projectRoot: string): string {
  return crypto.createHash('sha256').update(projectRoot).digest('hex');
}

export function getProjectTempDir(projectRoot: string): string {
  const hash = getProjectHash(projectRoot);
  return path.join(os.homedir(), GEMINI_DIR, TMP_DIR_NAME, hash);
}
```


# settings.errors 가 존재하는지 확인

이후 settings 의 error 가 존재 한다면 에러 메시지를 출력하고 종료

```typescript
if (settings.errors.length > 0) {
  ...
  process.exit(1);
}
```

그 다음 `parseArguments` 함수를 호출하여 명령행 인수를 파싱하고, `loadExtensions` 함수를 사용하여 확장 기능을 로드

```typescript
const argv = await parseArguments();
const extensions = loadExtensions(workspaceRoot);
const config = await loadCliConfig(
  settings.merged,
  extensions,
  sessionId,
  argv,
);
```

* args : https://github.com/google-gemini/gemini-cli/blob/main/docs/cli/configuration.md#command-line-arguments
* extensions : https://github.com/google-gemini/gemini-cli/blob/main/docs/extension.md

## parseArguments


## loadExtensions

**type**

```typescript
export interface Extension {
  path: string;
  config: ExtensionConfig;
  contextFiles: string[];
}
```

**핵심 역할**

> 확장 프로그램을 계층적으로 로드하고 중복을 제거





## localCliConfig

먼저 `Config` 는 `@google/gemini-cli-core` 패키지에서 가져온것, `sessionId` 또한 마찬가지

```typescript
import {
  Config,
  ...
} from '@google/gemini-cli-core';
```


> Config 에 대한 간략한 설명
>
> Config 클래스는 Gemini CLI의 중앙 설정 저장소이자 실행 환경의 청사진입니다. 모든 구성 요소가 동일한 설정을 참조하도록 하는 단일 진실 공급원(Single Source of Truth) 역할을 합니다. (세션 고유 식별자, 작업 디렉토리, 사용할 AI 모델 등을 포함)


```typescript
const debugMode =
  argv.debug ||
  [process.env.DEBUG, process.env.DEBUG_MODE].some(
    (v) => v === 'true' || v === '1',
  ) ||
  false;
const memoryImportFormat = settings.memoryImportFormat || 'tree';
const ideMode =
  (argv.ideMode ?? settings.ideMode ?? false) &&
  process.env.TERM_PROGRAM === 'vscode';

const ideModeFeature =
  (argv.ideModeFeature ?? settings.ideModeFeature ?? false) &&
  !process.env.SANDBOX;

const ideClient = IdeClient.getInstance(ideMode && ideModeFeature);

const allExtensions = annotateActiveExtensions(
  extensions,
  argv.extensions || [],
);

const activeExtensions = extensions.filter(
  (_, i) => allExtensions[i].isActive,
);
```

* debugMode : 디버그 모드 활성화 여부, CLI 인수(`--debug`) 또는 환경변수가 `true` 또는 `1`인 경우 활성화, 기본값은 `false`
* memoryImportFormat : 메모리 가져오기 형식, 기본값은 `tree`
* ideMode : VSCode에서 실행 중인지 확인 하는 여부
* ideModeFeature : IDE 모드 기능 활성화 여부, CLI 인수 또는 설정에서 가져오며, 샌드박스 환경에서는 비활성화
* ideClient : IDE 클라이언트 인스턴스, IDE 모드가 활성화된 경우에만 생성
* allExtensions : 활성화된 확장 기능 목록
* activeExtensions : 실제로 활성화된 확장 기능만 필터링

### process.env

> `process.env` 는 Node.js에서 현재 프로세스의 환경 변수를 나타내는 객체

vscode 에서 실행 중인지 확인하는 방법은 `process.env.TERM_PROGRAM` 이 `vscode` 인지 확인하는 것

### IdeClient

> Gemini CLI와 IDS(VScode) 간의 브릿지 역할을 하는 클래스 로서 CLI가 터미널에서 실행되면서 IDE와 실시간으로 소통할 수 있게 해주는 통신 관리자

### annotateActiveExtensions

**type**

```typescript
export interface GeminiCLIExtension {
  name: string;
  version: string;
  isActive: boolean;
  path: string;
}
```



***

# 전체 플로우 다이어그램

```
main() 시작
    ↓
┌─────────────────────────┐
│ 1. 초기 설정            │
│ - 작업 디렉토리 확인     │
│ - 설정 파일 로드        │
│ - 체크포인트 정리       │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 2. 설정 검증 및 파싱     │
│ - 명령행 인수 파싱      │
│ - 확장 기능 로드        │
│ - Config 객체 생성      │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 3. 환경 설정            │
│ - 인증 방식 설정        │
│ - 테마 로드            │
│ - 디버그 모드 설정      │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 4. 메모리/샌드박스 처리  │
│ - 메모리 요구사항 확인   │
│ - 샌드박스 환경 확인    │
│ - 필요시 프로세스 재시작 │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│ 5. UI 모드 결정         │
│ - TTY 환경 확인         │
│ - 입력 소스 결정        │
│ - 대화형/비대화형 분기   │
└─────────────────────────┘
    ↓
┌─────────┐    ┌──────────┐
│대화형 모드│    │비대화형   │
│React UI │    │stdin 처리 │
│렌더링    │    │직접 실행  │
└─────────┘    └──────────┘
```
